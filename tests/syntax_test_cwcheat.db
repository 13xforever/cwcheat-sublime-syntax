; SYNTAX TEST "Packages/User/cwcheat-sublime-syntax/cwcheat.sublime-syntax"

see https://datacrystal.romhacking.net/wiki/CwCheat

_L before _C
; <- invalid
_C0 before _G
; <- invalid
_G before _S
; <- invalid

_S Game ID that is used to match the section
; <- meta.namespace - invalid
; <- keyword.other.serial
;^   keyword.other.serial
;  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ entity.name.namespace
;^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ - invalid
_G User-friendly game name
; <- keyword.other.game
;^ keyword.other.game
_C0 Disabled cheat title
_L 0x00000000 0x00000000
_C1 Enabled cheat title
_L 0x00000001 0x00000000
_C2 Invalid cheat state
_C1 There should be at least one opcode inside
everything else is a comment
; <- comment.line - invalid
;^^^^^^^^^^^^^^^^^^^^^^^^^^^ comment.line - invalid
_s register shouldn't matter
; <- keyword.other.serial
;^   keyword.other.serial
;  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ entity.name.namespace
;^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ - invalid
_g for any
_c0 command


_S ULUS-00000
_G Constant Write, 8 bit
_C0 Correct
_L 0x00000000 0x00000000
_L 0x00000000 0x0000000f
_L 0x00000000 0x000000f0
_C1 Error
_L 0x00000000 0x00000f00
_L 0x00000000 0xf0000000

_S ULUS-00001
_G Constant Write, 16 bit
_C0 Correct
_L 0x10000000 0x00000000
_L 0x10000000 0x0000000f
_L 0x10000000 0x0000f000
_C1 Error
_L 0x10000000 0x000f0000
_L 0x10000000 0xf0000000

_S ULUS-00002
_G Constant Write, 32 bit
_C0 Correct
_L 0x20000000 0x00000000
_L 0x20000000 0x0000000f
_L 0x20000000 0x0000f000
_L 0x20000000 0xf0000000

_S ULUS-00003
_G Increment/decrement
_C0 Continuously add FF to the byte at address AAAAAAA
_L 0x301000FF 0x0AAAAAAA
_C1 Error
_L 0x30100FFF 0x0AAAAAAA
_L 0x3F1000FF 0x0AAAAAAA
_L 0x301000FF 0xFAAAAAAA

_C0 Continuously subtract FF from the byte at address AAAAAAA
_L 0x302000FF 0x0AAAAAAA
_C1 Error
_L 0x30200FFF 0x0AAAAAAA
_L 0x3F2000FF 0x0AAAAAAA
_L 0x302000FF 0xFAAAAAAA

_C0 Continuously add FFFF to the halfword at address AAAAAAA
_L 0x3030FFFF 0x0AAAAAAA
_C1 Error
_L 0x303FFFFF 0x0AAAAAAA
_L 0x3F30FFFF 0x0AAAAAAA
_L 0x3030FFFF 0xFAAAAAAA

_C0 Continuously subtract FFFF from the halfword at address AAAAAAA
_L 0x3040FFFF 0x0AAAAAAA
_C1 Error
_L 0x304FFFFF 0x0AAAAAAA
_L 0x3F40FFFF 0x0AAAAAAA
_L 0x3040FFFF 0xFAAAAAAA

_C0 Continuously add FFFFFFFF to the word at address AAAAAAA
_L 0x30500000 0x0AAAAAAA
_L 0xFFFFFFFF 0x00000000
_C1 Error
_L 0x3050000F 0x0AAAAAAA
_L 0xFFFFFFFF 0x00000000
_L 0x3F500000 0x0AAAAAAA
_L 0xFFFFFFFF 0x00000000
_L 0x30500000 0xFAAAAAAA
_L 0xFFFFFFFF 0x00000000

_C0 Continuously subtract FFFFFFFF from the word at address AAAAAAA
_L 0x30600000 0x0AAAAAAA
_L 0xFFFFFFFF 0x00000000
_C1 Error
_L 0x3060000F 0x0AAAAAAA
_L 0xFFFFFFFF 0x00000000
_L 0x3F600000 0x0AAAAAAA
_L 0xFFFFFFFF 0x00000000
_L 0x30600000 0xFAAAAAAA
_L 0xFFFFFFFF 0x00000000

_C1 Invalid sub-opcodes
_L 0x30700000 0x0AAAAAAA
_L 0x30800000 0x0AAAAAAA
_L 0x30900000 0x0AAAAAAA
_L 0x30a00000 0x0AAAAAAA
_L 0x30b00000 0x0AAAAAAA
_L 0x30c00000 0x0AAAAAAA
_L 0x30d00000 0x0AAAAAAA
_L 0x30e00000 0x0AAAAAAA
_L 0x30f00000 0x0AAAAAAA

_S ULUS-00004,8
_G Multi-Write
AAAAAAA = where to start writing
FFFFFFFF = first value to write
BBBB = number of values to write
CCCC * 4 = offset to add to the address after writing each value
EEEEEEEE = value to add to the value after writing each value 
_C0 8-bit, Correct
_L 0x8AAAAAAA 0xBBBBCCCC
_L 0x000000FF 0x000000EE
_C1 Error
_L 0x8AAAAAAA 0xBBBBCCCC
_L 0x00000FFF 0x000000EE
_L 0x8AAAAAAA 0xBBBBCCCC
_L 0x000000FF 0x00000EEE

_C0 16-bit, Correct
_L 0x8AAAAAAA 0xBBBBCCCC
_L 0x1000FFFF 0x0000EEEE 
_C1 Error
_L 0x8AAAAAAA 0xBBBBCCCC
_L 0x100FFFFF 0x0000EEEE 
_L 0x8AAAAAAA 0xBBBBCCCC
_L 0x1000FFFF 0x000EEEEE 
_L 0x8AAAAAAA 0xBBBBCCCC
_L 0x0000FFFF 0x000EEEEE 
_L 0x8AAAAAAA 0xBBBBCCCC
_L 0xF000FFFF 0x000EEEEE 

_C0 32-bit
_L 0x4AAAAAAA 0xBBBBCCCC
_L 0xFFFFFFFF 0xEEEEEEEE

_S ULUS-00005
_G Copy bytes
AAAAAAA = destination address
BBBBBBB = source address
FF = number of bytes?
_C1 Error
_L 0x5AAAAAAA 0x00000002
_L 0x0BBBBBBB 0x00000000

_S ULUS-00006
_G Pointer Commands
AAAAAAA = pointer location 
FFFFFFFF = value to write
11111111 = pointer offset
_C0 Add offset, 8 bit, Correct
_L 0x6AAAAAAA 0x000000FF
_L 0x00000001 0x01111111 
_C1 Error
_L 0x6AAAAAAA 0x00000FFF
_L 0x00000001 0x01111111 
_L 0x6AAAAAAA 0x000000FF
_L 0x00000001 0x11111111 
_L 0x6AAAAAAA 0x000000FF
_L 0x00100001 0x01111111 
_L 0x6AAAAAAA 0x000000FF
_L 0x00000002 0x01111111 
_L 0x6AAAAAAA 0x000000FF
_L 0x00000011 0x01111111 

_C0 Add offset, 16 bit, Correct
_L 0x6AAAAAAA 0x0000FFFF
_L 0x00010001 0x01111111 
_C1 Error
_L 0x6AAAAAAA 0x000FFFFF
_L 0x00010001 0x01111111 
_L 0x6AAAAAAA 0x0000FFFF
_L 0x00010001 0x11111111 
_L 0x6AAAAAAA 0x0000FFFF
_L 0x00110001 0x01111111 
_L 0x6AAAAAAA 0x0000FFFF
_L 0x00010002 0x01111111 
_L 0x6AAAAAAA 0x0000FFFF
_L 0x00010011 0x01111111 

_C0 Add offset, 32 bit, Correct
_L 0x6AAAAAAA 0xFFFFFFFF
_L 0x00020001 0x01111111 
_C1 Error
_L 0x6AAAAAAA 0xFFFFFFFF
_L 0x00020001 0x11111111 
_L 0x6AAAAAAA 0xFFFFFFFF
_L 0x00120001 0x01111111 
_L 0x6AAAAAAA 0xFFFFFFFF
_L 0x00020002 0x01111111 
_L 0x6AAAAAAA 0xFFFFFFFF
_L 0x00020011 0x01111111 

_C0 Subtract offset, 8 bit, Correct
_L 0x6AAAAAAA 0x000000FF
_L 0x00030001 0x01111111 
_C1 Error
_L 0x6AAAAAAA 0x00000FFF
_L 0x00030001 0x01111111 
_L 0x6AAAAAAA 0x000000FF
_L 0x00030001 0x11111111 
_L 0x6AAAAAAA 0x000000FF
_L 0x00130001 0x01111111 
_L 0x6AAAAAAA 0x000000FF
_L 0x00030002 0x01111111 
_L 0x6AAAAAAA 0x000000FF
_L 0x00030011 0x01111111 

_C0 Subtract offset, 16 bit, Correct
_L 0x6AAAAAAA 0x0000FFFF
_L 0x00040001 0x01111111 
_C1 Error
_L 0x6AAAAAAA 0x000FFFFF
_L 0x00040001 0x01111111 
_L 0x6AAAAAAA 0x0000FFFF
_L 0x00040001 0x11111111 
_L 0x6AAAAAAA 0x0000FFFF
_L 0x00140001 0x01111111 
_L 0x6AAAAAAA 0x0000FFFF
_L 0x00040002 0x01111111 
_L 0x6AAAAAAA 0x0000FFFF
_L 0x00040011 0x01111111 

_C0 Subtract offset, 32 bit, Correct
_L 0x6AAAAAAA 0xFFFFFFFF
_L 0x00050001 0x01111111 
_C1 Error
_L 0x6AAAAAAA 0xFFFFFFFF
_L 0x00050001 0x11111111 
_L 0x6AAAAAAA 0xFFFFFFFF
_L 0x00150001 0x01111111 
_L 0x6AAAAAAA 0xFFFFFFFF
_L 0x00050002 0x01111111 
_L 0x6AAAAAAA 0xFFFFFFFF
_L 0x00050011 0x01111111 

_C1 Invalid sub-opcodes
_L 0x6AAAAAAA 0xFFFFFFFF
_L 0x00060001 0x01111111 
_L 0x6AAAAAAA 0xFFFFFFFF
_L 0x000F0001 0x01111111 

_S ULUS-00007
_G Boolean Commands
With the value at AAAAAAA, do the boolean operation with FF and store the result
_C0 OR, 8 bit, Correct
_L 0x7AAAAAAA 0x000000FF
_C1 Error
_L 0x7AAAAAAA 0x001000FF
_L 0x7AAAAAAA 0x00000FFF

_C0 AND, 8 bit, Correct
_L 0x7AAAAAAA 0x000200FF
_C1 Error
_L 0x7AAAAAAA 0x001200FF
_L 0x7AAAAAAA 0x00020FFF

_C0 XOR, 8 bit, Correct
_L 0x7AAAAAAA 0x000400FF
_C1 Error
_L 0x7AAAAAAA 0x001400FF
_L 0x7AAAAAAA 0x00040FFF

_C0 OR, 16 bit, Correct
_L 0x7AAAAAAA 0x0001FFFF
_C1 Error
_L 0x7AAAAAAA 0x0011FFFF

_C0 AND, 16 bit, Correct
_L 0x7AAAAAAA 0x0003FFFF
_C1 Error
_L 0x7AAAAAAA 0x0013FFFF

_C0 XOR, 16 bit, Correct
_L 0x7AAAAAAA 0x0005FFFF
_C1 Error
_L 0x7AAAAAAA 0x0015FFFF

_C1 Invalid sub-opcodes
_L 0x7AAAAAAA 0x00060000
_L 0x7AAAAAAA 0x00070000
_L 0x7AAAAAAA 0x00090000
_L 0x7AAAAAAA 0x000A0000
_L 0x7AAAAAAA 0x000F0000

_S ULUS-00009-C
_G Invalid opcode
_C1 Error
_L 0x90000000 0x00000000
_L 0xA0000000 0x00000000
_L 0xB0000000 0x00000000
_L 0xC0000000 0x00000000

_S ULUS-0000D
_G Conditionals
_C0 EQUAL: Execute the next code if the byte at address AAAAAAA equals FF (otherwise, it is skipped) 
_L 0xDAAAAAAA 0x200000FF
_C1 Error
_L 0xDAAAAAAA 0x20000FFF
_L 0xDAAAAAAA 0x210000FF
_L 0xDAAAAAAA 0x200100FF
_C0 NOT EQUAL: Execute the next code if the byte at address AAAAAAA does not equal FF (otherwise, it is skipped)
_L 0xDAAAAAAA 0x201000FF
_C1 Error
_L 0xDAAAAAAA 0x20100FFF
_L 0xDAAAAAAA 0x211000FF
_L 0xDAAAAAAA 0x201100FF
_C0 LESS THAN: Execute the next code if the byte at address AAAAAAA is less than FF (otherwise, it is skipped)
_L 0xDAAAAAAA 0x202000FF 
_C1 Error
_L 0xDAAAAAAA 0x20200FFF 
_L 0xDAAAAAAA 0x212000FF 
_L 0xDAAAAAAA 0x202100FF 
_C0 GREATER THAN: Execute the next code if the byte at address AAAAAAA is greater than FF (otherwise, it is skipped)
_L 0xDAAAAAAA 0x203000FF
_C1 Error
_L 0xDAAAAAAA 0x20300FFF
_L 0xDAAAAAAA 0x213000FF
_L 0xDAAAAAAA 0x203100FF

_C0 EQUAL: Execute the next code if the halfword at address AAAAAAA equals FFFF (otherwise, it is skipped)
_L 0xDAAAAAAA 0x0000FFFF 
_C1 Error
_L 0xDAAAAAAA 0x0100FFFF 
_L 0xDAAAAAAA 0x0001FFFF 
_C0 NOT EQUAL: Execute the next code if the halfword at address AAAAAAA does not equal FFFF (otherwise, it is skipped)
_L 0xDAAAAAAA 0x0010FFFF
_C1 Error
_L 0xDAAAAAAA 0x0110FFFF
_L 0xDAAAAAAA 0x0011FFFF
_C0 LESS THAN: Execute the next code if the halfword at address AAAAAAA is less than FFFF (otherwise, it is skipped)
_L 0xDAAAAAAA 0x0020FFFF 
_C1 Error
_L 0xDAAAAAAA 0x0120FFFF 
_L 0xDAAAAAAA 0x0021FFFF 
_C0 GREATER THAN: Execute the next code if the halfword at address AAAAAAA is greater than FFFF (otherwise, it is skipped) 
_L 0xDAAAAAAA 0x0030FFFF
_C1 Error
_L 0xDAAAAAAA 0x0130FFFF
_L 0xDAAAAAAA 0x0031FFFF

_C1 Invalid sub-opcodes
_L 0xDAAAAAAA 0x00400000
_L 0xDAAAAAAA 0x00F00000
_L 0xDAAAAAAA 0x20400000
_L 0xDAAAAAAA 0x20F00000

_G Comparison
EQUAL: If the values at addresses AAAAAAA and BBBBBBB are equal, execute the next FF lines (otherwise, they are skipped) 
_C0 EQUAL, 8 bit, Correct
_L 0xDAAAAAAA 0x4BBBBBBB
_L 0x000000FF 0x00000000 
_C0 EQUAL, 16 bit, Correct
_L 0xDAAAAAAA 0x4BBBBBBB
_L 0x000000FF 0x00000001
_C0 EQUAL, 32 bit, Correct
_L 0xDAAAAAAA 0x4BBBBBBB
_L 0x000000FF 0x00000002
_C1 Error
_L 0xDAAAAAAA 0x4BBBBBBB
_L 0x00000FFF 0x00000000 
_L 0xDAAAAAAA 0x4BBBBBBB
_L 0x000000FF 0x00000003
_L 0xDAAAAAAA 0x4BBBBBBB
_L 0x000000FF 0x00000010

NOT EQUAL: If the values at addresses AAAAAAA and BBBBBBB are not equal, execute the next NN lines (otherwise, they are skipped) 
_C0 NOT EQUAL, 8 bit, Correct
_L 0xDAAAAAAA 0x5BBBBBBB
_L 0x000000FF 0x00000000
_C0 NOT EQUAL, 16 bit, Correct
_L 0xDAAAAAAA 0x5BBBBBBB
_L 0x000000FF 0x00000001
_C0 NOT EQUAL, 32 bit, Correct
_L 0xDAAAAAAA 0x5BBBBBBB
_L 0x000000FF 0x00000002
_C1 Error
_L 0xDAAAAAAA 0x5BBBBBBB
_L 0x00000FFF 0x00000000 
_L 0xDAAAAAAA 0x5BBBBBBB
_L 0x000000FF 0x00000003
_L 0xDAAAAAAA 0x5BBBBBBB
_L 0x000000FF 0x00000010

LESS THAN: If the value at address AAAAAAA is less than the value at address BBBBBBB, execute the next FF lines (otherwise, they are skipped) 
_C0 LESS THAN, 8 bit, Correct
_L 0xDAAAAAAA 0x6BBBBBBB
_L 0x000000FF 0x00000000
_C0 LESS THAN, 16 bit, Correct
_L 0xDAAAAAAA 0x6BBBBBBB
_L 0x000000FF 0x00000001
_C0 LESS THAN, 32 bit, Correct
_L 0xDAAAAAAA 0x6BBBBBBB
_L 0x000000FF 0x00000002
_C1 Error
_L 0xDAAAAAAA 0x6BBBBBBB
_L 0x00000FFF 0x00000000 
_L 0xDAAAAAAA 0x6BBBBBBB
_L 0x000000FF 0x00000003
_L 0xDAAAAAAA 0x6BBBBBBB
_L 0x000000FF 0x00000010

GREATER THAN: If the value at address AAAAAAA is greater than the value at address BBBBBBB, execute the next NN lines (otherwise, they are skipped)
_C0 GREATER THAN, 8 bit, Correct
_L 0xDAAAAAAA 0x7BBBBBBB
_L 0x000000FF 0x00000000
_C0 GREATER THAN, 16 bit, Correct
_L 0xDAAAAAAA 0x7BBBBBBB
_L 0x000000FF 0x00000001
_C0 GREATER THAN, 32 bit, Correct
_L 0xDAAAAAAA 0x7BBBBBBB
_L 0x000000FF 0x00000002
_C1 Error
_L 0xDAAAAAAA 0x7BBBBBBB
_L 0x00000FFF 0x00000000 
_L 0xDAAAAAAA 0x7BBBBBBB
_L 0x000000FF 0x00000003
_L 0xDAAAAAAA 0x7BBBBBBB
_L 0x000000FF 0x00000010

_C1 Invalid sub-opcodes
_L 0xDAAAAAAA 0x10000000
_L 0xDAAAAAAA 0x30000000
_L 0xDAAAAAAA 0x80000000
_L 0xDAAAAAAA 0x90000000
_L 0xDAAAAAAA 0xA0000000
_L 0xDAAAAAAA 0xF0000000

_S ULUS-0000E
_G Conditionals (Multiple Skip)
_C0 EQUAL: Execute the next CC lines if the byte at address AAAAAAA equals FF (otherwise, it is skipped)
_L 0xE1CC00FF 0x0AAAAAAA
_C0 NOT EQUAL: Execute the next CC lines if the byte at address AAAAAAA does not equal FF (otherwise, they are skipped)
_L 0xE1CC00FF 0x1AAAAAAA
_C0 LESS THAN: Execute the next CC lines if the byte at address AAAAAAA is less than FF (otherwise, they are skipped)
_L 0xE1CC00FF 0x2AAAAAAA
_C0 GREATER THAN: Execute the next CC lines if the byte at address AAAAAAA is greater than FF (otherwise, they are skipped)
_L 0xE1CC00FF 0x3AAAAAAA
_C1 Error
_L 0xE1CC0FFF 0x0AAAAAAA
_L 0xE1CC00FF 0x4AAAAAAA

_C0 EQUAL: Execute the next CC lines if the halfword at address AAAAAAA equals FFFF (otherwise, they are skipped)
_L 0xE0CCFFFF 0x0AAAAAAA
_C0 NOT EQUAL: Execute the next CC lines if the halfword at address AAAAAAA does not equal FFFF (otherwise, they are skipped)
_L 0xE0CCFFFF 0x1AAAAAAA
_C0 LESS THAN: Execute the next CC lines if the halfword at address AAAAAAA is less than FFFF (otherwise, they are skipped)
_L 0xE0CCFFFF 0x2AAAAAAA
_C0 GREATER THAN: Execute the next code if the halfword at address AAAAAAA is greater than FFFF (otherwise, they are skipped) 
_L 0xE0CCFFFF 0x3AAAAAAA 
_C1 Error
_L 0xE0CCFFFF 0x1AAAAAAA

_C1 Invalid sub-opcodes
_L 0xE2000000 0x00000000
_L 0xEF000000 0x00000000

_S ULUS-0000F
_G Invalid opcode
_C1 Error
_L 0xF0000000 0x00000000
